import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import svdvals, pinv
from scipy.integrate import solve_ivp
from scipy.sparse import csr_matrix
from scipy.sparse.linalg import expm_multiply
import sympy as sp
import time
import logging

# Logging Setup with More Detail
logging.basicConfig(
    filename='toe_6d_stable.log',
    level=logging.DEBUG,
    format='%(asctime)s.%(msecs)03d - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger("TOE6D")

# Physical Constants
G = 6.67430e-11
c = 2.99792458e8
hbar = 1.0545718e-10
e = 1.60217662e-19
epsilon_0 = 8.854187817e-6
mu_0 = 1 / (epsilon_0 * c**2)
m_e = 9.1093837e-31
m_q = 2.3e-30
m_h = 2.23e-30
m_n = 1.67e-28
g_w = 0.653
g_s = 1.221
v_higgs = 246e9 * e / c**2
l_p = np.sqrt(hbar * G / c**3)
kappa = 1e-8
lambda_higgs = 0.5
alpha = 1 / 137.0
yukawa_e = 2.9e-6
yukawa_q = 1.2e-5
RS = 2.0 * G * m_n / c**2

# Pauli and Gell-Mann Matrices
sigma = [
    np.array([[0, 1], [1, 0]], dtype=np.complex64),
    np.array([[0, -1j], [1j, 0]], dtype=np.complex64),
    np.array([[1, 0], [0, -1]], dtype=np.complex64)
]
lambda_matrices = [
    np.array([[0, 1, 0], [1, 0, 0], [0, 0, 0]], dtype=np.complex64),
    np.array([[0, -1j, 0], [1j, 0, 0], [0, 0, 0]], dtype=np.complex64),
    np.array([[1, 0, 0], [0, -1, 0], [0, 0, 0]], dtype=np.complex64),
    np.array([[0, 0, 1], [0, 0, 0], [1, 0, 0]], dtype=np.complex64),
    np.array([[0, 0, -1j], [0, 0, 0], [1j, 0, 0]], dtype=np.complex64),
    np.array([[0, 0, 0], [0, 0, 1], [0, 1, 0]], dtype=np.complex64),
    np.array([[0, 0, 0], [0, 0, -1j], [0, 1j, 0]], dtype=np.complex64),
    np.array([[1, 0, 0], [0, 1, 0], [0, 0, -2]]) / np.sqrt(3, dtype=np.complex64)
]
f_su2 = np.zeros((3, 3, 3), dtype=np.float64)
for a, b, c in [(0, 1, 2), (1, 2, 0), (2, 0, 1)]: f_su2[a, b, c] = 1
for a, b, c in [(2, 1, 0), (0, 2, 1), (1, 0, 2)]: f_su2[a, b, c] = -1
f_su3 = np.zeros((8, 8, 8), dtype=np.float64)
f_su3[0, 1, 2] = 1; f_su3[0, 2, 1] = -1
f_su3[0, 3, 4] = 0.5; f_su3[0, 4, 3] = -0.5
f_su3[0, 5, 6] = 0.5; f_su3[0, 6, 5] = -0.5
f_su3[1, 3, 5] = 0.5; f_su3[1, 5, 3] = -0.5
f_su3[1, 4, 6] = -0.5; f_su3[1, 6, 4] = 0.5
f_su3[2, 3, 6] = 0.5; f_su3[2, 6, 3] = -0.5
f_su3[2, 4, 5] = 0.5; f_su3[2, 5, 4] = -0.5
f_su3[3, 4, 7] = np.sqrt(3)/2; f_su3[3, 7, 4] = -np.sqrt(3)/2
f_su3[5, 6, 7] = np.sqrt(3)/2; f_su3[5, 7, 6] = -np.sqrt(3)/2

# Configuration
CONFIG = {
    "grid_size": (5, 5, 5, 5, 3, 3),
    "max_iterations": 100,
    "time_delay_steps": 3,
    "ctc_feedback_factor": 5.0,
    "entanglement_factor": 0.2,
    "charge": e,
    "em_strength": 3.0,
    "dt": 1e-12,  # Initial dt, will be adjusted dynamically
    "dx": l_p * 1e5,
    "dv": l_p * 1e3,
    "du": l_p * 1e3,
    "alpha_em": alpha,
    "alpha_phi": 1e-3,
    "m_nugget": m_n,
    "m_higgs": m_h,
    "m_electron": m_e,
    "m_quark": m_q,
    "vev_higgs": v_higgs,
    "yukawa_e": yukawa_e,
    "yukawa_q": yukawa_q,
    "g_strong": g_s * 1e-5,
    "g_weak": g_w * 1e-5,
    "omega": 3,
    "a_godel": 1.0,
    "entanglement_coupling": 1e-6,
    "j4_scaling_factor": 1e-20,
    "sample_rate": 22050,
    "log_tensors": True,
    "flux_coupling": 1e-3,
    "resonance_frequency": 1e6,
    "resonance_amplitude": 0.1,
    "field_clamp_max": 1e6,
    "rtol": 1e-6,
    "atol": 1e-9,
    "dt_min": 1e-15,  # Minimum allowable dt
    "dt_max": 1e-9,   # Maximum allowable dt
    "max_steps_per_dt": 1000  # Maximum internal steps per dt
}
START_TIME = time.perf_counter_ns() / 1e9

# Helper Functions
def compute_entanglement_entropy(field, grid_size):
    entropy = np.zeros(grid_size[:4], dtype=np.float64)
    for idx in np.ndindex(grid_size[:4]):
        local_state = field[idx].flatten()
        local_state = np.nan_to_num(local_state, nan=0.0)
        norm = np.linalg.norm(local_state)
        if norm > 1e-15:
            local_state /= norm
        psi_matrix = local_state.reshape(2, 2)
        schmidt_coeffs = svdvals(psi_matrix)
        probs = schmidt_coeffs**2
        probs = probs[probs > 1e-15]
        entropy[idx] = -np.sum(probs * np.log(probs)) if probs.size > 0 else 0
    if np.any(np.isnan(entropy)):
        logger.warning("NaN detected in entanglement entropy calculation")
    return np.mean(entropy)

def repeating_curve(index):
    return 1 if index % 2 == 0 else 0

def construct_6d_gamma_matrices(metric):
    gamma_flat = [
        np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1, 0], [0, 0, 0, -1]], dtype=np.complex64),
        np.array([[0, 0, 0, 1], [0, 0, 1, 0], [0, -1, 0, 0], [-1, 0, 0, 0]], dtype=np.complex64),
        np.array([[0, 0, 0, -1j], [0, 0, 1j, 0], [0, 1j, 0, 0], [-1j, 0, 0, 0]], dtype=np.complex64),
        np.array([[0, 0, 1, 0], [0, 0, 0, -1], [-1, 0, 0, 0], [0, 1, 0, 0]], dtype=np.complex64),
        np.eye(4, dtype=np.complex64),
        np.eye(4, dtype=np.complex64)
    ]
    e_a_mu = np.diag([np.sqrt(abs(metric[i, i])) + 1e-15 for i in range(6)], dtype=np.float64)
    e_mu_a = np.linalg.inv(e_a_mu)
    gamma = [sum(e_mu_a[mu, a] * gamma_flat[a] for a in range(6)) for mu in range(6)]
    return [np.nan_to_num(g, nan=0.0) for g in gamma]

def compute_schumann_frequencies(N=3):
    f0 = 7.83e3
    pythagorean_ratios = [1, 2, 8/3]
    return [f0 * ratio for ratio in pythagorean_ratios[:N]]

# Spin Network Class
class SpinNetwork:
    def __init__(self, grid_size):
        self.grid_size = grid_size
        self.total_points = np.prod(grid_size)
        self.state = np.ones(self.total_points, dtype=np.complex128) / np.sqrt(self.total_points)
        self.indices = np.arange(self.total_points).reshape(grid_size)
        self.ctc_buffer = []
        self.ctc_steps = CONFIG["time_delay_steps"]
        self.ctc_factor = CONFIG["ctc_feedback_factor"]

    def evolve(self, dt, lambda_field, metric, inverse_metric, deltas, phi_N, higgs_field, em_fields, electron_field, quark_field):
        H = self._build_sparse_hamiltonian(lambda_field, metric, inverse_metric, deltas, phi_N, higgs_field, em_fields, electron_field, quark_field)
        state_flat = self.state.flatten()
        max_attempts = 3
        current_dt = dt
        for attempt in range(max_attempts):
            try:
                if len(self.ctc_buffer) >= self.ctc_steps:
                    state_past = self.ctc_buffer[-self.ctc_steps].flatten()
                    state_current = state_flat.copy()
                    for _ in range(3):
                        sol = solve_ivp(lambda t, y: -1j * H.dot(y) / hbar, [0, current_dt], state_current,
                                        method='RK45', rtol=CONFIG["rtol"], atol=CONFIG["atol"])
                        if not sol.success:
                            raise ValueError("solve_ivp failed in SpinNetwork evolve")
                        state_evolved = sol.y[:, -1]
                        state_current = (1 - self.ctc_factor) * state_evolved + self.ctc_factor * state_past
                        norm = np.linalg.norm(state_current)
                        if norm > 0:
                            state_current /= norm
                        else:
                            logger.warning("Zero norm in SpinNetwork state evolution")
                            state_current = state_flat.copy()
                else:
                    sol = solve_ivp(lambda t, y: -1j * H.dot(y) / hbar, [0, current_dt], state_flat,
                                    method='RK45', rtol=CONFIG["rtol"], atol=CONFIG["atol"])
                    if not sol.success:
                        raise ValueError("solve_ivp failed in SpinNetwork initial evolve")
                    state_current = sol.y[:, -1]
                    norm = np.linalg.norm(state_current)
                    if norm > 0:
                        state_current /= norm
                    else:
                        logger.warning("Zero norm in SpinNetwork initial state evolution")
                        state_current = state_flat.copy()
                break
            except Exception as e:
                logger.warning(f"SpinNetwork evolve failed with dt={current_dt}: {e}, attempt {attempt+1}/{max_attempts}")
                if attempt == max_attempts - 1:
                    raise
                current_dt *= 0.5  # Reduce dt and retry
                logger.info(f"Retrying with reduced dt={current_dt}")
        self.state = state_current.reshape(self.grid_size)
        self.state = np.clip(self.state, -CONFIG["field_clamp_max"], CONFIG["field_clamp_max"])
        self.ctc_buffer.append(self.state.copy())
        if len(self.ctc_buffer) > self.ctc_steps:
            self.ctc_buffer.pop(0)
        # Return the number of steps taken by solve_ivp for adaptive dt adjustment
        return len(sol.t) - 1

    def _build_sparse_hamiltonian(self, lambda_field, metric, inverse_metric, deltas, phi_N, higgs_field, em_fields, electron_field, quark_field):
        state_grid = self.state.reshape(self.grid_size)
        N = self.total_points
        kinetic_term = np.zeros_like(state_grid, dtype=np.complex128)
        for mu in range(6):
            grad_mu = np.gradient(state_grid, deltas[mu], axis=mu)
            laplacian_mu = np.gradient(grad_mu, deltas[mu], axis=mu)
            kinetic_term += inverse_metric[..., mu, mu] * laplacian_mu
        kinetic_energy = -hbar**2 / (2 * m_n) * kinetic_term.flatten()
        
        potential_energy = np.zeros(N, dtype=np.complex128)
        phi_N_flat = phi_N.flatten()
        higgs_norm = np.abs(higgs_field.flatten())**2
        em_potential = np.abs(em_fields["A"][..., 0].flatten())
        for i in range(N):
            V_phi = kappa * phi_N_flat[i]**2
            V_higgs = lambda_higgs * higgs_norm[i]
            V_em = e * em_potential[i]
            potential_energy[i] = V_phi + V_higgs + V_em
        
        connection = self._compute_affine_connection(metric, inverse_metric, deltas)
        spin_gravity = np.zeros(N, dtype=np.complex128)
        for idx in np.ndindex(self.grid_size):
            i = self.indices[idx]
            psi_e = electron_field[idx]
            spin_e = np.einsum('i,ij,j->', psi_e.conj(), sigma[2], psi_e).real
            psi_q = quark_field[idx]
            spin_q = 0
            for f in range(2):
                for c in range(3):
                    psi_q_fc = psi_q[f, c]
                    spin_q += np.einsum('i,ij,j->', psi_q_fc.conj(), sigma[2], psi_q_fc).real
            spin_density = (m_e * spin_e + m_q * spin_q) / (hbar * c)
            for mu in range(6):
                spin_gravity[i] += spin_density * connection[idx + (mu, mu, mu)]
        
        lambda_perturbation = lambda_field.flatten() * 1e-3
        diagonal = kinetic_energy + potential_energy + hbar * c * spin_gravity * 1e-3 + lambda_perturbation
        if np.any(np.isnan(diagonal)):
            logger.warning("NaN detected in Hamiltonian diagonal")
        
        rows, cols, data = [], [], []
        for idx in np.ndindex(self.grid_size):
            i = self.indices[idx]
            for mu in range(6):
                idx_plus = list(idx)
                idx_minus = list(idx)
                if idx[mu] < self.grid_size[mu] - 1:
                    idx_plus[mu] += 1
                    j = self.indices[tuple(idx_plus)]
                    coupling = inverse_metric[idx][mu, mu] * hbar * c / deltas[mu]
                    rows.extend([i, j])
                    cols.extend([j, i])
                    data.extend([coupling, coupling])
                if idx[mu] > 0:
                    idx_minus[mu] -= 1
                    j = self.indices[tuple(idx_minus)]
                    coupling = inverse_metric[idx][mu, mu] * hbar * c / deltas[mu]
                    rows.extend([i, j])
                    cols.extend([j, i])
                    data.extend([coupling, coupling])
        
        H = csr_matrix((data, (rows, cols)), shape=(N, N), dtype=np.complex128)
        H += csr_matrix((diagonal, (np.arange(N), np.arange(N))), dtype=np.complex128)
        return H

    def _compute_affine_connection(self, metric, inverse_metric, deltas):
        connection = np.zeros((*self.grid_size, 6, 6, 6), dtype=np.float64)
        for idx in np.ndindex(self.grid_size):
            if all(0 < i < s - 1 for i, s in zip(idx, self.grid_size)):
                for rho in range(6):
                    for mu in range(6):
                        for nu in range(6):
                            dg_mu = np.gradient(metric[..., mu, nu], deltas[rho], axis=rho)[idx]
                            dg_nu = np.gradient(metric[..., rho, mu], deltas[nu], axis=nu)[idx]
                            dg_rho = np.gradient(metric[..., rho, nu], deltas[mu], axis=mu)[idx]
                            connection[idx + (rho, mu, nu)] = 0.5 * np.einsum('rs,s->r', inverse_metric[idx],
                                                                              dg_mu + dg_nu - dg_rho)
        if np.any(np.isnan(connection)):
            logger.warning("NaN detected in affine connection")
        return np.nan_to_num(connection, nan=0.0)

# Tetrahedral Lattice Class
class TetrahedralLattice:
    def __init__(self, grid_size):
        self.grid_size = grid_size
        self.coordinates = self._generate_coordinates()

    def _generate_coordinates(self):
        dims = [np.linspace(0, CONFIG[f"d{dim}"] * size, size, dtype=np.float64)
                for dim, size in zip(['t', 'x', 'x', 'x', 'v', 'u'], self.grid_size)]
        return np.stack(np.meshgrid(*dims, indexing='ij'), axis=-1)

# Unified 6D TOE Simulation Class
class Unified6DTOE:
    def __init__(self):
        self.grid_size = CONFIG["grid_size"]
        self.total_points = np.prod(self.grid_size)
        self.dt = CONFIG["dt"]  # Initial dt, will be adjusted dynamically
        self.deltas = [CONFIG[f"d{dim}"] for dim in ['t', 'x', 'x', 'x', 'v', 'u']]
        self.time = 0.0
        
        self.spin_network = SpinNetwork(self.grid_size)
        self.lattice = TetrahedralLattice(self.grid_size)
        self.wormhole_nodes = self._generate_wormhole_nodes()
        
        self.bit_states = np.array([repeating_curve(sum(idx)) for idx in np.ndindex(self.grid_size)],
                                  dtype=np.int8).reshape(self.grid_size)
        self.temporal_entanglement = np.zeros(self.grid_size, dtype=np.complex128)
        self.quantum_state = np.ones(self.grid_size, dtype=np.complex128) / np.sqrt(self.total_points)
        self.higgs_field = np.ones(self.grid_size, dtype=np.complex128) * v_higgs
        self.electron_field = np.zeros((*self.grid_size, 4), dtype=np.complex128)
        self.quark_field = np.zeros((*self.grid_size, 2, 3, 4), dtype=np.complex128)
        self.phi_N = np.zeros(self.grid_size, dtype=np.float64)
        self.lambda_field = np.zeros(self.grid_size, dtype=np.float64)
        self.phi_range = np.linspace(-10.0, 10.0, 201, dtype=np.float64)
        self.d_phi = self.phi_range[1] - self.phi_range[0]
        self.phi_wave_functions = np.zeros((*self.grid_size, len(self.phi_range)), dtype=np.complex128)
        for idx in np.ndindex(self.grid_size):
            psi = np.exp(-self.phi_range**2)
            psi /= np.sqrt(np.sum(np.abs(psi)**2 * self.d_phi))
            self.phi_wave_functions[idx] = psi
        
        self.setup_symbolic_calculations()
        self.metric, self.inverse_metric = self.compute_quantum_metric()
        self.connection = self._compute_affine_connection()
        self.riemann_tensor = self._compute_riemann_tensor()
        self.ricci_tensor, self.ricci_scalar = self._compute_curvature()
        self.stress_energy = self._compute_stress_energy()
        self.einstein_tensor = self._compute_einstein_tensor()
        
        self.em_fields = self._initialize_em_fields()
        self.weak_fields = self._initialize_weak_fields()
        self.strong_fields = self._initialize_strong_fields()
        
        self.history = []
        self.fermion_history = []
        self.phi_N_history = []
        self.higgs_norm_history = []
        self.entanglement_history = []
        self.ricci_scalar_history = []
        self.spin_density_history = []
        self.lambda_history = []
        self.j4_history = []
        self.flux_history = []

    def setup_symbolic_calculations(self):
        self.t, self.x, self.y, self.z, self.v, self.u = sp.symbols('t x y z v u')
        self.a, self.c_sym, self.m, self.kappa_sym = sp.symbols('a c m kappa', positive=True)
        self.phi_N_sym = sp.Function('phi_N')(self.t, self.x, self.y, self.z, self.v, self.u)
        r = sp.sqrt(self.x**2 + self.y**2 + self.z**2 + 1e-10)
        schwarzschild = 1 - RS / r
        scaled_l_p = l_p * 1e30
        time_scale = 1e-16
        spatial_scale = 1.0
        compact_scale = 1e18
        g_diag = [
            sp.sympify(time_scale * (-self.c_sym**2 * (1 + self.kappa_sym * self.phi_N_sym) * schwarzschild)),
            sp.sympify(spatial_scale * (self.a**2 * (1 + self.kappa_sym * self.phi_N_sym))),
            sp.sympify(spatial_scale * (self.a**2 * (1 + self.kappa_sym * self.phi_N_sym))),
            sp.sympify(spatial_scale * (self.a**2 * (1 + self.kappa_sym * self.phi_N_sym))),
            sp.sympify(compact_scale * (scaled_l_p**2)),
            sp.sympify(compact_scale * (scaled_l_p**2))
        ]
        logger.debug("g_diag elements types: %s", [type(elem) for elem in g_diag])
        try:
            self.g = sp.diag(*g_diag)
        except Exception as e:
            logger.warning(f"sp.diag failed: {e}, falling back to manual construction")
            self.g = sp.zeros(6, 6)
            for i in range(6):
                self.g[i, i] = g_diag[i]
        self.g_inv = self.g.inv()
        self.metric_scale_factors = np.array([time_scale, spatial_scale, spatial_scale, spatial_scale, compact_scale, compact_scale])

    def _generate_wormhole_nodes(self):
        coords = np.zeros((*self.grid_size, 6), dtype=np.float64)
        dims = [np.linspace(0, CONFIG[f"d{dim}"] * size, size, dtype=np.float64)
                for dim, size in zip(['t', 'x', 'x', 'x', 'v', 'u'], self.grid_size)]
        T, X, Y, Z, V, U = np.meshgrid(*dims, indexing='ij')
        R, r = 1.5 * self.deltas[1], 0.5 * self.deltas[1]
        coords[..., 0] = (R + r * np.cos(CONFIG["omega"] * T)) * np.cos(X / self.deltas[1])
        coords[..., 1] = (R + r * np.cos(CONFIG["omega"] * T)) * np.sin(Y / self.deltas[1])
        coords[..., 2] = r * np.sin(CONFIG["omega"] * Z)
        coords[..., 3] = r * np.cos(CONFIG["omega"] * V)
        coords[..., 4] = r * np.sin(CONFIG["omega"] * U)
        coords[..., 5] = c * T
        return np.nan_to_num(coords, nan=0.0)

    def compute_quantum_metric(self):
        metric = np.zeros((*self.grid_size, 6, 6), dtype=np.float64)
        coords = self.lattice.coordinates
        for idx in np.ndindex(self.grid_size):
            subs_dict = {
                self.t: coords[idx][0], self.x: coords[idx][1], self.y: coords[idx][2],
                self.z: coords[idx][3], self.v: coords[idx][4], self.u: coords[idx][5],
                self.a: CONFIG["a_godel"], self.c_sym: c, self.m: m_n,
                self.kappa_sym: kappa, self.phi_N_sym: self.phi_N[idx]
            }
            g = np.array(sp.N(self.g.subs(subs_dict)), dtype=np.float64)
            if np.any(np.isnan(g)) or np.any(np.isinf(g)):
                logger.warning(f"NaN/Inf detected in metric at idx {idx}: {g}")
                g = np.nan_to_num(g, nan=0.0, posinf=1e6, neginf=-1e6)
            metric[idx] = 0.5 * (g + g.T)
        cond = np.linalg.cond(metric)
        logger.debug(f"Metric condition number: {cond.max()}")
        if np.any(cond > 1e10):
            logger.warning(f"High condition number detected: {cond.max()}")
            inverse_metric = pinv(metric, rcond=1e-10)
        else:
            inverse_metric = np.linalg.inv(metric + 1e-5 * np.eye(6, dtype=np.float64))
        scale_matrix = np.diag(1.0 / self.metric_scale_factors)
        for idx in np.ndindex(self.grid_size):
            inverse_metric[idx] = scale_matrix @ inverse_metric[idx] @ scale_matrix
        return np.nan_to_num(metric, nan=0.0), np.nan_to_num(inverse_metric, nan=0.0)

    def _compute_affine_connection(self):
        connection = np.zeros((*self.grid_size, 6, 6, 6), dtype=np.float64)
        dg_dmu = [np.gradient(self.metric[..., i, j], self.deltas[k], axis=k)
                  for k in range(6) for i in range(6) for j in range(6)]
        dg_dmu = np.array(dg_dmu).reshape(6, 6, 6, *self.grid_size)
        for rho in range(6):
            for mu in range(6):
                for nu in range(6):
                    term = (dg_dmu[mu, nu, :] + dg_dmu[nu, mu, :] -
                            np.sum(dg_dmu[:, mu, nu] * self.inverse_metric[..., rho, :], axis=-1))
                    connection[..., rho, mu, nu] = 0.5 * term.transpose(1, 2, 3, 4, 5, 0)
        if np.any(np.isnan(connection)):
            logger.warning("NaN detected in affine connection")
        return np.nan_to_num(connection, nan=0.0)

    def _compute_riemann_tensor(self):
        riemann = np.zeros((*self.grid_size, 6, 6, 6, 6), dtype=np.complex128)
        for rho in range(6):
            for sigma in range(6):
                for mu in range(6):
                    for nu in range(6):
                        grad_nu_sigma = np.gradient(self.connection[..., rho, nu, sigma], self.deltas[nu], axis=nu)
                        grad_mu_sigma = np.gradient(self.connection[..., rho, mu, sigma], self.deltas[mu], axis=mu)
                        term1 = np.einsum('...km,...mn->...kn', self.connection[..., rho, :, mu],
                                          self.connection[..., :, nu, sigma])
                        term2 = np.einsum('...kn,...mn->...km', self.connection[..., rho, :, nu],
                                          self.connection[..., :, mu, sigma])
                        riemann[..., rho, sigma, mu, nu] = (grad_nu_sigma - grad_mu_sigma + term1 - term2)
        max_val = np.max(np.abs(riemann))
        if max_val > 1e5:
            riemann /= max_val
            logger.info(f"Riemann tensor scaled by {max_val} to prevent overflow")
        if np.any(np.isnan(riemann)):
            logger.warning("NaN detected in Riemann tensor")
        return np.nan_to_num(riemann, nan=0.0)

    def _compute_curvature(self):
        ricci_tensor = np.einsum('...rsmn,...mn->...rs', self.riemann_tensor, self.inverse_metric)
        ricci_scalar = np.einsum('...mn,...mn->...', self.inverse_metric, ricci_tensor)
        if np.any(np.isnan(ricci_tensor)) or np.any(np.isnan(ricci_scalar)):
            logger.warning("NaN detected in curvature computation")
        return np.nan_to_num(ricci_tensor, nan=0.0), np.nan_to_num(ricci_scalar, nan=0.0)

    def _compute_stress_energy(self):
        T = np.zeros((*self.grid_size, 6, 6), dtype=np.complex128)
        F = self.em_fields["F"]
        F_nu_alpha = np.einsum('...nu, ...beta, ...alpha->...nu alpha', F, self.inverse_metric, self.metric)
        T_em = (np.einsum('...mu alpha,...nu alpha->...mu nu', F, F_nu_alpha) -
                0.25 * self.metric * np.einsum('...ab,...ab->...', F, F)) / (4 * np.pi * epsilon_0)
        T += T_em
        T += self.em_fields["J4"][..., np.newaxis, np.newaxis] * self.metric
        quantum_amplitude = np.abs(self.quantum_state)**2
        T[..., 0, 0] += -self.phi_N / c**2 + quantum_amplitude
        for i in range(1, 6):
            T[..., i, i] += quantum_amplitude / 5
        if np.any(np.isnan(T)):
            logger.warning("NaN detected in stress-energy tensor")
        return np.nan_to_num(T, nan=0.0)

    def _compute_einstein_tensor(self):
        ricci_tensor, ricci_scalar = self._compute_curvature()
        einstein_tensor = ricci_tensor - 0.5 * self.metric * ricci_scalar[..., np.newaxis, np.newaxis]
        if np.any(np.isnan(einstein_tensor)):
            logger.warning("NaN detected in Einstein tensor")
        return np.nan_to_num(einstein_tensor, nan=0.0)

    def _initialize_em_fields(self):
        A = np.zeros((*self.grid_size, 6), dtype=np.complex128)
        r = np.linalg.norm(self.wormhole_nodes[..., :3], axis=-1) + 1e-15
        A[..., 0] = CONFIG["charge"] / (4 * np.pi * epsilon_0 * r)
        F = np.zeros((*self.grid_size, 6, 6), dtype=np.complex128)
        J = np.zeros((*self.grid_size, 6), dtype=np.complex128)
        base_J = CONFIG["charge"] * c / (4 * np.pi * r**3)
        omega_res = 2 * np.pi * CONFIG["resonance_frequency"]
        resonance = 1 + CONFIG["resonance_amplitude"] * np.sin(omega_res * self.time)
        J[..., 0] = base_J * resonance
        for mu in range(6):
            for nu in range(6):
                grad_A_nu = np.gradient(A[..., nu], self.deltas[mu], axis=mu)
                grad_A_mu = np.gradient(A[..., mu], self.deltas[nu], axis=nu)
                F[..., mu, nu] = grad_A_nu - grad_A_mu
        J_norm = np.einsum('...m,...m->...', J, J)
        k = 2 * np.pi * 1e21
        x = k * self.lambda_field
        coupling = (-x**2 * np.cos(x) + 2 * x * np.sin(x) + 2 * np.cos(x)) * CONFIG["j4_scaling_factor"]
        J4 = J_norm**2 * coupling
        if np.any(np.isnan(J4)):
            logger.warning("NaN detected in J4 computation")
        return {"A": A, "F": F, "J": J, "J4": J4}

    def _initialize_weak_fields(self):
        W = np.random.normal(0, 1e-3, (*self.grid_size, 3, 6)).astype(np.complex128) * hbar * c / self.deltas[1]
        F_W = np.zeros((*self.grid_size, 3, 6, 6), dtype=np.complex128)
        for a in range(3):
            for mu in range(6):
                for nu in range(6):
                    dW_mu = np.gradient(W[..., a, nu], self.deltas[mu], axis=mu)
                    dW_nu = np.gradient(W[..., a, mu], self.deltas[nu], axis=nu)
                    nonlinear = CONFIG["g_weak"] * np.einsum('abc,...b,...c->...a', f_su2, W[..., mu], W[..., nu])[..., a]
                    F_W[..., a, mu, nu] = dW_mu - dW_nu + nonlinear
        return {"W": W, "F": F_W}

    def _initialize_strong_fields(self):
        G = np.random.normal(0, 1e-3, (*self.grid_size, 8, 6)).astype(np.complex128) * hbar * c / self.deltas[1]
        F_G = np.zeros((*self.grid_size, 8, 6, 6), dtype=np.complex128)
        for a in range(8):
            for mu in range(6):
                for nu in range(6):
                    dG_mu = np.gradient(G[..., a, nu], self.deltas[mu], axis=mu)
                    dG_nu = np.gradient(G[..., a, mu], self.deltas[nu], axis=nu)
                    nonlinear = CONFIG["g_strong"] * np.einsum('abc,...b,...c->...a', f_su3, G[..., mu], G[..., nu])[..., a]
                    F_G[..., a, mu, nu] = dG_mu - dG_nu + nonlinear
        return {"G": G, "F": F_G}

    def evolve_gauge_fields(self):
        for a in range(8):
            for mu in range(6):
                for nu in range(6):
                    dG_mu = np.gradient(self.strong_fields['G'][..., a, nu], self.deltas[mu], axis=mu)
                    dG_nu = np.gradient(self.strong_fields['G'][..., a, mu], self.deltas[nu], axis=nu)
                    nonlinear = CONFIG["g_strong"] * np.einsum('abc,...b,...c->...a', f_su3,
                                                              self.strong_fields['G'][..., mu],
                                                              self.strong_fields['G'][..., nu])[..., a]
                    self.strong_fields['F'][..., a, mu, nu] = dG_mu - dG_nu + nonlinear
        for a in range(3):
            for mu in range(6):
                for nu in range(6):
                    dW_mu = np.gradient(self.weak_fields['W'][..., a, nu], self.deltas[mu], axis=mu)
                    dW_nu = np.gradient(self.weak_fields['W'][..., a, mu], self.deltas[nu], axis=nu)
                    nonlinear = CONFIG["g_weak"] * np.einsum('abc,...b,...c->...a', f_su2,
                                                            self.weak_fields['W'][..., mu],
                                                            self.weak_fields['W'][..., nu])[..., a]
                    self.weak_fields['F'][..., a, mu, nu] = dW_mu - dW_nu + nonlinear
        if np.any(np.isnan(self.strong_fields['F'])) or np.any(np.isnan(self.weak_fields['F'])):
            logger.warning("NaN detected in gauge fields")

    def evolve_phi_wave_functions(self):
        F_squared = np.einsum('...mn,...mn->...', self.em_fields["F"], self.em_fields["F"])
        phase_factor = np.exp(-1j * CONFIG["alpha_phi"] * (F_squared + self.em_fields["J4"])[..., np.newaxis] *
                              self.phi_range * self.dt / hbar)
        self.phi_wave_functions *= phase_factor
        kinetic_coeff = -hbar**2 / (2 * m_n * self.d_phi**2)
        second_deriv = (self.phi_wave_functions[..., 2:] - 2 * self.phi_wave_functions[..., 1:-1] +
                        self.phi_wave_functions[..., :-2]) / self.d_phi**2
        self.phi_wave_functions[..., 1:-1] += (-1j * kinetic_coeff * second_deriv * self.dt / hbar)
        self.phi_wave_functions[..., 0] = self.phi_wave_functions[..., 1]
        self.phi_wave_functions[..., -1] = self.phi_wave_functions[..., -2]
        norm = np.sqrt(np.sum(np.abs(self.phi_wave_functions)**2 * self.d_phi, axis=-1))[..., np.newaxis]
        if np.any(norm == 0):
            logger.warning("Zero norm detected in phi wave functions")
            norm = np.where(norm == 0, 1e-15, norm)
        self.phi_wave_functions /= norm
        self.phi_wave_functions = np.clip(self.phi_wave_functions, -CONFIG["field_clamp_max"], CONFIG["field_clamp_max"])

    def update_phi_N_from_wave_functions(self):
        self.phi_N = np.sum(self.phi_range * np.abs(self.phi_wave_functions)**2 * self.d_phi, axis=-1)
        self.phi_N = np.clip(self.phi_N, -CONFIG["field_clamp_max"], CONFIG["field_clamp_max"])
        if np.any(np.isnan(self.phi_N)):
            logger.warning("NaN detected in phi_N")

    def evolve_higgs_field(self):
        def higgs_deriv(t, h_flat):
            h = h_flat.reshape(self.grid_size)
            d2_higgs = sum(np.gradient(np.gradient(h, self.deltas[i], axis=i), self.deltas[i], axis=i)
                           for i in range(6))
            h_norm = np.abs(h)**2
            dV_dH = -m_h * c**2 * h + lambda_higgs * h_norm * h
            return (-d2_higgs + dV_dH).flatten()
        
        h_flat = self.higgs_field.flatten()
        max_attempts = 3
        current_dt = self.dt
        for attempt in range(max_attempts):
            try:
                sol = solve_ivp(higgs_deriv, [0, current_dt], h_flat, method='RK45',
                                rtol=CONFIG["rtol"], atol=CONFIG["atol"])
                if not sol.success:
                    raise ValueError("solve_ivp failed in evolve_higgs_field")
                break
            except Exception as e:
                logger.warning(f"evolve_higgs_field failed with dt={current_dt}: {e}, attempt {attempt+1}/{max_attempts}")
                if attempt == max_attempts - 1:
                    raise
                current_dt *= 0.5
                logger.info(f"Retrying with reduced dt={current_dt}")
        self.higgs_field = sol.y[:, -1].reshape(self.grid_size)
        self.higgs_field = np.nan_to_num(self.higgs_field, nan=v_higgs)
        self.higgs_field = np.clip(self.higgs_field, -CONFIG["field_clamp_max"], CONFIG["field_clamp_max"])
        if np.any(np.isnan(self.higgs_field)):
            logger.warning("NaN detected in Higgs field")
        # Return the number of steps taken for adaptive dt adjustment
        return len(sol.t) - 1

    def evolve_fermion_fields(self):
        total_steps = 0
        for idx in np.ndindex(self.grid_size):
            psi_e = self.electron_field[idx]
            H_e = self.dirac_hamiltonian(psi_e, idx, quark=False)
            max_attempts = 3
            current_dt = self.dt
            for attempt in range(max_attempts):
                try:
                    sol_e = solve_ivp(lambda t, y: -1j * H_e.dot(y) / hbar, [0, current_dt], psi_e,
                                      method='RK45', rtol=CONFIG["rtol"], atol=CONFIG["atol"])
                    if not sol_e.success:
                        raise ValueError("solve_ivp failed in evolve_fermion_fields for electron")
                    break
                except Exception as e:
                    logger.warning(f"evolve_fermion_fields (electron) failed with dt={current_dt}: {e}, attempt {attempt+1}/{max_attempts}")
                    if attempt == max_attempts - 1:
                        raise
                    current_dt *= 0.5
                    logger.info(f"Retrying with reduced dt={current_dt}")
            self.electron_field[idx] = sol_e.y[:, -1]
            total_steps += len(sol_e.t) - 1

            for f in range(2):
                for c in range(3):
                    psi_q = self.quark_field[idx, f, c]
                    H_q = self.dirac_hamiltonian(psi_q, idx, quark=True, flavor=f, color=c)
                    for attempt in range(max_attempts):
                        try:
                            sol_q = solve_ivp(lambda t, y: -1j * H_q.dot(y) / hbar, [0, current_dt], psi_q,
                                              method='RK45', rtol=CONFIG["rtol"], atol=CONFIG["atol"])
                            if not sol_q.success:
                                raise ValueError("solve_ivp failed in evolve_fermion_fields for quark")
                            break
                        except Exception as e:
                            logger.warning(f"evolve_fermion_fields (quark) failed with dt={current_dt}: {e}, attempt {attempt+1}/{max_attempts}")
                            if attempt == max_attempts - 1:
                                raise
                            current_dt *= 0.5
                            logger.info(f"Retrying with reduced dt={current_dt}")
                    self.quark_field[idx, f, c] = sol_q.y[:, -1]
                    total_steps += len(sol_q.t) - 1

        self.electron_field = np.nan_to_num(self.electron_field, nan=0.0)
        self.quark_field = np.nan_to_num(self.quark_field, nan=0.0)
        self.electron_field = np.clip(self.electron_field, -CONFIG["field_clamp_max"], CONFIG["field_clamp_max"])
        self.quark_field = np.clip(self.quark_field, -CONFIG["field_clamp_max"], CONFIG["field_clamp_max"])
        if np.any(np.isnan(self.electron_field)) or np.any(np.isnan(self.quark_field)):
            logger.warning("NaN detected in fermion fields")
        return total_steps

    def dirac_hamiltonian(self, psi, idx, quark=False, flavor=None, color=None):
        gamma_mu = construct_6d_gamma_matrices(self.metric[idx])
        mass = m_q if quark else m_e
        D_mu_psi = [np.gradient(self.electron_field if not quark else self.quark_field[..., flavor, color], self.deltas[i], axis=i)
                    [idx] if i < len(psi.shape) else psi for i in range(6)]
        H_psi = -1j * c * sum(gamma_mu[0] @ gamma_mu[i] @ D_mu_psi[i] for i in range(1, 6))
        H_psi += (mass * c**2 / hbar) * gamma_mu[0] @ psi
        H_psi -= 1j * e * sum(self.em_fields["A"][idx][mu] * gamma_mu[mu] @ psi for mu in range(6))
        if quark and flavor is not None and color is not None:
            T_a = lambda_matrices
            strong_term = sum(CONFIG["g_strong"] * self.strong_fields['G'][idx][a, mu] * T_a[a][color, color] * psi
                              for a in range(8) for mu in range(6))
            H_psi += -1j * strong_term
        if np.any(np.isnan(H_psi)):
            logger.warning("NaN detected in Dirac Hamiltonian")
        return np.nan_to_num(H_psi, nan=0.0)

    def compute_lambda(self, t, coords, N=3):
        frequencies = compute_schumann_frequencies(N)
        omega = [2 * np.pi * f for f in frequencies]
        lambda_field = np.zeros(self.grid_size, dtype=np.float64)
        x = coords[..., 1] / self.deltas[1]
        for n in range(N):
            A_n = 1e-21
            term = (-x**2 * np.cos(omega[n] * t) + 2 * x * np.sin(omega[n] * t) +
                    2 * np.cos(omega[n] * t))
            lambda_field += A_n * term
        if np.any(np.isnan(lambda_field)):
            logger.warning("NaN detected in lambda field")
        return np.nan_to_num(lambda_field, nan=0.0)

    def compute_rio_pattern(self, iteration):
        P = np.abs(self.quantum_state)**2
        F = np.sqrt(np.sum([np.gradient(self.phi_N, self.deltas[mu], axis=mu)**2 for mu in range(6)], axis=0))
        phi_shifted = np.roll(self.phi_N, shift=[1, 1, 0, 0, 0, 0], axis=tuple(range(6)))
        M = np.cos(CONFIG["alpha_phi"] * P) * np.cos(CONFIG["alpha_phi"] * phi_shifted)
        return M * F, F

    def compute_quantum_flux(self):
        psi = self.quantum_state
        psi_conj = np.conj(psi)
        J = np.zeros((*self.grid_size, 6), dtype=np.complex128)
        for mu in range(6):
            grad_psi = np.gradient(psi, self.deltas[mu], axis=mu)
            grad_psi_conj = np.gradient(psi_conj, self.deltas[mu], axis=mu)
            J[..., mu] = (hbar / (2 * m_n * 1j)) * (psi_conj * grad_psi - psi * grad_psi_conj)
        J_mag = np.sqrt(np.sum(np.abs(J)**2, axis=-1))
        if np.any(np.isnan(J_mag)):
            logger.warning("NaN detected in quantum flux magnitude")
        return J, J_mag

    def adjust_time_step(self, steps_taken):
        # Adjust dt based on the number of internal steps taken by solve_ivp
        target_steps = 10  # Ideal number of internal steps per dt
        if steps_taken > CONFIG["max_steps_per_dt"]:
            # Too many steps, reduce dt
            self.dt *= 0.5
            logger.info(f"Reducing dt to {self.dt} due to excessive steps ({steps_taken})")
        elif steps_taken > target_steps * 1.5:
            # Slightly too many steps, reduce dt slightly
            self.dt *= 0.9
            logger.debug(f"Reducing dt to {self.dt} (steps: {steps_taken})")
        elif steps_taken < target_steps * 0.5 and steps_taken > 0:
            # Too few steps, increase dt
            self.dt *= 1.1
            logger.debug(f"Increasing dt to {self.dt} (steps: {steps_taken})")
        # Enforce dt bounds
        self.dt = max(CONFIG["dt_min"], min(self.dt, CONFIG["dt_max"]))
        logger.debug(f"Adjusted dt: {self.dt}")

    def quantum_walk(self, iteration):
        t_start = self.time
        t_end = t_start + self.dt
        max_attempts = 3
        current_dt = self.dt
        total_steps = 0
        for attempt in range(max_attempts):
            try:
                self.time = t_start
                self.lambda_field = self.compute_lambda(self.time, self.lattice.coordinates)
                
                steps = self.spin_network.evolve(current_dt, self.lambda_field, self.metric, self.inverse_metric,
                                                self.deltas, self.phi_N, self.higgs_field, self.em_fields,
                                                self.electron_field, self.quark_field)
                total_steps += steps
                
                prob = np.abs(self.quantum_state)**2
                V_j4_phi = CONFIG["flux_coupling"] * self.em_fields["J4"] * self.phi_N
                def quantum_deriv(t, q_flat):
                    q = q_flat.reshape(self.grid_size)
                    kinetic = np.sum([np.gradient(np.gradient(q, self.deltas[mu], axis=mu), self.deltas[mu], axis=mu)
                                      for mu in range(6)], axis=0)
                    return (-hbar**2 / (2 * m_n) * kinetic + V_j4_phi * q).flatten()
                q_flat = self.quantum_state.flatten()
                sol = solve_ivp(quantum_deriv, [0, current_dt], q_flat, method='RK45',
                                rtol=CONFIG["rtol"], atol=CONFIG["atol"])
                if not sol.success:
                    raise ValueError("solve_ivp failed in quantum_walk")
                self.quantum_state = sol.y[:, -1].reshape(self.grid_size)
                norm = np.linalg.norm(self.quantum_state)
                if norm > 0:
                    self.quantum_state /= norm
                else:
                    logger.warning("Zero norm in quantum state evolution")
                self.quantum_state = np.clip(self.quantum_state, -CONFIG["field_clamp_max"], CONFIG["field_clamp_max"])
                total_steps += len(sol.t) - 1
                
                if len(self.fermion_history) >= CONFIG["time_delay_steps"]:
                    past_field = self.fermion_history[-CONFIG["time_delay_steps"]][1]
                    self.electron_field += CONFIG["ctc_feedback_factor"] * (past_field - self.electron_field) * current_dt
                
                self.temporal_entanglement = CONFIG["entanglement_factor"] * prob
                flip_mask = np.random.random(self.grid_size) < np.abs(self.em_fields["A"][..., 0] * CONFIG["em_strength"] *
                                                                      self.temporal_entanglement)
                self.bit_states[flip_mask] = 1 - self.bit_states[flip_mask]
                
                self.em_fields = self._initialize_em_fields()
                self.evolve_gauge_fields()
                self.evolve_phi_wave_functions()
                self.update_phi_N_from_wave_functions()
                
                steps = self.evolve_higgs_field()
                total_steps += steps
                
                steps = self.evolve_fermion_fields()
                total_steps += steps
                
                self.metric, self.inverse_metric = self.compute_quantum_metric()
                self.connection = self._compute_affine_connection()
                self.riemann_tensor = self._compute_riemann_tensor()
                self.ricci_tensor, self.ricci_scalar = self._compute_curvature()
                self.stress_energy = self._compute_stress_energy()
                self.einstein_tensor = self._compute_einstein_tensor()
                
                spin_density = np.zeros(self.grid_size, dtype=np.float64)
                for idx in np.ndindex(self.grid_size):
                    psi_e = self.electron_field[idx]
                    spin_e = np.einsum('i,ij,j->', psi_e.conj(), sigma[2], psi_e).real
                    spin_density[idx] = spin_e
                
                _, J_mag = self.compute_quantum_flux()
                
                timestamp = time.perf_counter_ns()
                self.history.append((timestamp, self.bit_states.copy()))
                self.fermion_history.append((timestamp, self.electron_field.copy()))
                self.phi_N_history.append(self.phi_N[0, 0, 0, 0, 0, 0])
                self.higgs_norm_history.append(np.mean(np.abs(self.higgs_field)))
                self.entanglement_history.append(compute_entanglement_entropy(self.electron_field, self.grid_size))
                rio_pattern, _ = self.compute_rio_pattern(iteration)
                self.ricci_scalar_history.append(self.ricci_scalar[0, 0, 0, 0, 0, 0].real)
                self.lambda_history.append(self.lambda_field[0, 0, 0, 0, 0, 0])
                self.spin_density_history.append(spin_density[0, :, :, 0, 0, 0])
                self.j4_history.append(self.em_fields["J4"][0, 0, 0, 0, 0, 0])
                self.flux_history.append(J_mag[0, :, :, 0, 0, 0])
                
                logger.info(f"Iteration {iteration}: Ricci Scalar = {self.ricci_scalar[0, 0, 0, 0, 0, 0].real:.6e}, "
                            f"Higgs Norm = {self.higgs_norm_history[-1]:.6e}, J4 = {self.j4_history[-1]:.6e}, "
                            f"Flux Mag = {np.mean(J_mag):.6e}")
                
                self.time = t_end
                break
            except Exception as e:
                logger.warning(f"quantum_walk failed with dt={current_dt}: {e}, attempt {attempt+1}/{max_attempts}")
                if attempt == max_attempts - 1:
                    raise
                current_dt *= 0.5
                logger.info(f"Retrying with reduced dt={current_dt}")
                self.dt = current_dt
        # Adjust dt for the next iteration based on total steps taken
        self.adjust_time_step(total_steps)

    def adjust_time_step(self, steps_taken):
        target_steps = 10
        if steps_taken > CONFIG["max_steps_per_dt"]:
            self.dt *= 0.5
            logger.info(f"Reducing dt to {self.dt} due to excessive steps ({steps_taken})")
        elif steps_taken > target_steps * 1.5:
            self.dt *= 0.9
            logger.debug(f"Reducing dt to {self.dt} (steps: {steps_taken})")
        elif steps_taken < target_steps * 0.5 and steps_taken > 0:
            self.dt *= 1.1
            logger.debug(f"Increasing dt to {self.dt} (steps: {steps_taken})")
        self.dt = max(CONFIG["dt_min"], min(self.dt, CONFIG["dt_max"]))
        logger.debug(f"Adjusted dt: {self.dt}")

    def visualize(self):
        fig = plt.figure(figsize=(18, 12))
        
        ax1 = fig.add_subplot(231, projection='3d')
        x, y, z = self.wormhole_nodes[0, :, :, :, 0, 0, :3].reshape(-1, 3).T
        sc = ax1.scatter(x, y, z, c=self.bit_states[0, :, :, :, 0, 0].flatten(), cmap='viridis')
        plt.colorbar(sc, label='Bit State')
        ax1.set_title('Spacetime Grid (t=0, v=u=0)')
        
        ax2 = fig.add_subplot(232)
        ax2.plot(self.phi_N_history, label='φ_N')
        ax2.set_title('Nugget Field Evolution')
        ax2.legend()
        
        ax3 = fig.add_subplot(233)
        ax3.plot(self.higgs_norm_history, label='Higgs Norm', color='orange')
        ax3.set_title('Higgs Field Norm')
        ax3.legend()
        
        ax4 = fig.add_subplot(234)
        ax4.plot(self.ricci_scalar_history, label='Ricci Scalar', color='red')
        ax4.set_title('Ricci Scalar Evolution')
        ax4.legend()
        
        ax5 = fig.add_subplot(235)
        ax5.plot(self.entanglement_history, label='Entanglement Entropy', color='green')
        ax5.set_title('Entanglement Entropy')
        ax5.legend()
        
        ax6 = fig.add_subplot(236)
        spin_slice = self.spin_density_history[-1]
        im = ax6.imshow(spin_slice, cmap='plasma')
        plt.colorbar(im, ax=ax6, label='Electron Spin Density')
        ax6.set_title('Spin Density (t=0, v=u=0)')
        
        plt.tight_layout()
        plt.savefig(f'toe_6d_iter_{len(self.history)}.png')
        plt.close()

    def visualize_quantum_flux(self):
        flux_slice = self.flux_history[-1]
        fig, ax = plt.subplots(figsize=(8, 6))
        
        im = ax.imshow(flux_slice, cmap='viridis', interpolation='nearest')
        plt.colorbar(im, ax=ax, label='Quantum Flux Magnitude')
        ax.set_title('Quantum Flux with Capacitor Resonance (t=0, z=0, v=0, u=0)')
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        
        for i in range(0, self.grid_size[1], 2):
            for j in range(0, self.grid_size[2], 2):
                rect = plt.Rectangle((i-0.4, j-0.4), 0.8, 0.8, fill=False, edgecolor='gray', linewidth=1)
                ax.add_patch(rect)
                if i < self.grid_size[1] - 1:
                    ax.plot([i+0.4, i+1.6], [j, j], color='gray', linestyle='-', linewidth=1)
                if j < self.grid_size[2] - 1:
                    ax.plot([i, i], [j+0.4, j+1.6], color='gray', linestyle='-', linewidth=1)
        
        plt.savefig('quantum_flux_with_resonance.png')
        plt.close()

    def run(self):
        print("Starting 6D TOE Simulation with Capacitor Resonance and Adaptive Time Stepping...")
        for i in range(CONFIG["max_iterations"]):
            try:
                self.quantum_walk(i)
                if i % 10 == 0:
                    self.visualize()
                    self.visualize_quantum_flux()
                    if CONFIG["log_tensors"]:
                        np.savetxt(f"metric_iter{i}.txt", self.metric[0, 0, 0, 0, 0, 0], fmt='%.6e')
            except Exception as e:
                logger.error(f"Error in iteration {i}: {e}")
                break
        self.visualize()
        self.visualize_quantum_flux()
        print("Simulation complete.")
